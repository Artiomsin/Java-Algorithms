# Java-Algorithms
## Sonarcloud: https://sonarcloud.io/project/overview?id=Artiomsin_Java-Algorithms

# Задания
### 1.3 Контейнеры, очереди, стеки
  1) Задание 1.3.40 [1.3/task_40/src/org/example](PLAN: 0.8 FACT: 0.6)
     + **Условие:**
     Сдвиг в начало. Напишите программу для чтения символов из стандартного ввода и сохранения их в связном списке без повторов. При вводе символа, 
     который раньше не встречался, вставьте его в начало списка. При вводе уже знакомого символа удалите его из списка и снова вставьте в начало. 
     Назовите программу MoveToFront: она реализует известную стратегию сдвига в начало (move to front), которая удобна при кешировании, сжатии 
     данных и во многих других приложениях, где недавно обработанные элементы с большей вероятностьюмогут встретиться вновь.

  2) Задание 1.3.14 [1.3/task_14/src/org/example](PLAN: 0.5 FACT: 0.45)
     + **Условие:**
     Разработайте класс ResizingArrayQueue0fStrings, когорый реализует абстракцию очереди с массивом фиксированного размера, а потом добавьте в полученную 
     реализацию изменение размера массива, чтобы снять ограничение на размер.

  3) Задание 1.3.27 [1.3/task_27/src/org/example](PLAN: 0.3 FACT: 0.25)
     + **Условие:**
     Напишите метод mах(), который принимает в качестве аргумента первый узел связного списка и возвращает значение максимального элемента в этом списке. Все 
     элементы представляют собой положительные целые числа. В случае пустого списка нужно возвратить значение 0.
 
  4) Задание 1.3.28 [1.3/task_28/src/org/example](PLAN: 0.15 FACT: 0.1)
     + **Условие:**
     Разработайте рекурсивное решение предыдущего задания.

### 2.5 Применение сортировок

### 3.2 Деревья бинарного поиска

### 3.3 Сбалансированные деревья поиска

### 3.4 Хеш-таблицы

### 5.1 Сортировка строк

### 5.2 Trie-деревья

### 5.3 Поиск подстрок

### 5.4 Регулярные выражения

